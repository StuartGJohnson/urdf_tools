<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Robot Viewer (Babylon.js diag)</title>
    <style>
      html,body{margin:0;height:100%;background:#0b0c10}
      #renderCanvas{width:100%;height:100%;display:block;touch-action:none}
      #status{
        position:fixed;left:8px;top:8px;padding:8px 12px;max-width:60ch;
        font:12px/1.35 system-ui,sans-serif;color:#e5eef5;
        background:rgba(0,0,0,.55);border-radius:8px;z-index:10;white-space:pre-wrap
      }
    </style>
    <!-- Non-module globals (safest for GH Pages) -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  </head>
  <body>
    <div id="status">Booting…</div>
    <canvas id="renderCanvas"></canvas>

    <script>
      // >>>> CHANGE THIS TO YOUR FILE NAME <<<<
      const MODEL_FILE = './ugv.glb';  // e.g., './ugv.glb'

      const S = document.getElementById('status');
      const log = (...a)=>{ console.log(...a); S.textContent = a.join(' ') };
      const append = (...a)=>{ console.log(...a); S.textContent += '\n' + a.join(' ') };

      // Basic engine/scene/camera
      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});
      const scene  = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.043,0.047,0.063,1.0); // #0b0c10

      const cam = new BABYLON.ArcRotateCamera("cam", -Math.PI/4, Math.PI/3, 3.0, BABYLON.Vector3.Zero(), scene);
      cam.lowerBetaLimit = 0.03;
      cam.upperBetaLimit = Math.PI - 0.03;
      cam.wheelDeltaPercentage = 0.02;
      cam.panningSensibility = 800;
      cam.attachControl(canvas, true);

      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
      hemi.intensity = 0.7;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5,-1,-0.6), scene);
      dir.position = new BABYLON.Vector3(5,10,7);
      dir.intensity = 1.1;

      // Always-visible fallback so screen is never blank
      const fallback = BABYLON.MeshBuilder.CreateBox("fallback", {width:1, height:0.3, depth:0.6}, scene);
      const fbMat = new BABYLON.StandardMaterial("fbMat", scene);
      fbMat.diffuseColor = new BABYLON.Color3(0.30,0.78,0.31);
      fbMat.specularColor = new BABYLON.Color3(0,0,0);
      fallback.material = fbMat;
      fallback.setEnabled(true);  // visible until GLB loads

      function frame(meshes) {
          // Compute world-space AABB of the model
          const min = new BABYLON.Vector3(+Infinity, +Infinity, +Infinity);
          const max = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity);
          meshes.forEach(m => {
              const bi = m.getBoundingInfo?.();
              if (!bi) return;
              min.minimizeInPlace(bi.boundingBox.minimumWorld);
              max.maximizeInPlace(bi.boundingBox.maximumWorld);
          });

          const center = min.add(max).scale(0.5);
          const size   = max.subtract(min);
          const maxDim = Math.max(size.x, size.y, size.z) || 1.0;

          // Put camera back far enough to see the whole object
          cam.setTarget(center);
          cam.radius = Math.max(maxDim * 1.3, 0.001);

          // === CRITICAL: frustum near/far ===
          // Near should be tiny relative to your working scale but not so small it wrecks depth precision.
          // Far should be comfortably beyond the model extents at current radius.
          const near = Math.max(1e-4, cam.radius / 2000);   // e.g. 0.0005 when radius=1.0
          const far  = Math.max(10.0, cam.radius * 2000);   // e.g. 2000 when radius=1.0
          cam.minZ = near;
          cam.maxZ = far;

          // Optional: zoom/pan limits that scale with the model
          cam.lowerRadiusLimit = maxDim * 0.05;
          cam.upperRadiusLimit = maxDim * 50.0;
      }

      // Start render loop immediately (shows fallback cube even if GLB fails)
      engine.runRenderLoop(()=>scene.render());
      window.addEventListener('resize', ()=>engine.resize());

      // Report engine info
      append('Renderer:', engine.description || 'OK', '| WebGL:', engine.webGLVersion);

      // Load GLB (cache-busted)
      log('Loading model…', MODEL_FILE);
      BABYLON.SceneLoader.Append("", MODEL_FILE + '?v=' + Date.now(), scene, () => {
        append('Model loaded.');

        // Hide fallback if we actually got meshes
        const meshes = scene.meshes.filter(m => m !== cam && m !== fallback);
        if (meshes.length > 0) {
          fallback.setEnabled(false);
          // If you exported with --glb-convention gltf/y_up, no rotation needed.
          // If you exported in URDF axes and it's sideways, uncomment:
          // meshes.forEach(m => m.rotation.x = -Math.PI/2);

          frame(meshes);
        } else {
          append('Loaded, but found 0 meshes. Keeping fallback visible.');
          frame([fallback]);
        }
      },
      (evt) => {
        if (evt.lengthComputable) append(`Progress: ${(evt.loaded/evt.total*100).toFixed(1)}%`);
        else append(`Progress: ${Math.round(evt.loaded/1024)} kB`);
      },
      (scene, message, exception) => {
        console.error('GLB load error:', message, exception);
        append('ERROR:', message);
        append('Showing fallback cube. Check filename/path & case.');
        frame([fallback]);
      });
    </script>
  </body>
</html>
