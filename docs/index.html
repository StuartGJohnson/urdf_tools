<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Robot Viewer (Three.js)</title>
    <style>
      html,body{margin:0;height:100%;background:#0b0c10}
      canvas{display:block}
      #status{
        position:fixed;left:8px;top:8px;padding:6px 10px;
        font:12px/1.2 system-ui, sans-serif;color:#cfd8dc;
        background:rgba(0,0,0,.4);border-radius:6px;z-index:10
      }
      #hint{
        position:fixed;left:8px;bottom:8px;padding:6px 10px;
        font:12px/1.2 system-ui, sans-serif;color:#cfd8dc;
        background:rgba(0,0,0,.4);border-radius:6px;opacity:.8
      }
    </style>
  </head>
  <body>
    <div id="status">Loading…</div>
    <div id="hint">Drag to orbit • Wheel/trackpad to zoom • Shift+drag to pan</div>

    <script type="module">
      const MODEL_FILE = './ugv.glb';  // <-- change to './ugv.glb' if that’s your filename

      // Tip: if you open this via file:// the imports below will fail. Use a local server or GitHub Pages.
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js';
      import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/controls/OrbitControls.js';
      import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/loaders/GLTFLoader.js';

      const statusEl = document.getElementById('status');
      const setStatus = (msg) => (statusEl.textContent = msg);

      // Set up renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);

      // Scene & camera
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c10);

      const camera = new THREE.PerspectiveCamera(
        50, window.innerWidth / window.innerHeight, 0.01, 2000
      );
      camera.position.set(2, 1.5, 2);

      // Controls: unbounded azimuth
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enablePan = true;
      controls.minPolarAngle = 0.0001;
      controls.maxPolarAngle = Math.PI - 0.0001;
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle =  Infinity;

      // Lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 7);
      scene.add(dir);

      // Helpers
      const grid = new THREE.GridHelper(10, 20, 0x334155, 0x1f2937);
      grid.position.y = -0.001;
      scene.add(grid);

      // Fallback cube (hidden by default)
      const fallbackGeom = new THREE.BoxGeometry(1, 0.3, 0.6);
      const fallbackMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
      const fallbackMesh = new THREE.Mesh(fallbackGeom, fallbackMat);
      fallbackMesh.visible = false;
      scene.add(fallbackMesh);

      // Load GLB
      const loader = new GLTFLoader();
      loader.load(
        MODEL_FILE,
        (gltf) => {
          setStatus('Loaded model.');
          const root = gltf.scene;
          scene.add(root);

          // Frame the model
          const bbox = new THREE.Box3().setFromObject(root);
          if (!isFinite(bbox.min.x + bbox.max.x)) {
            setStatus('Model bbox invalid (NaN/Inf). Showing fallback.');
            fallbackMesh.visible = true;
            frameObject(fallbackMesh);
          } else {
            frameObject(root, bbox);
          }
        },
        (xhr) => {
          if (xhr.total) {
            const pct = (xhr.loaded / xhr.total * 100).toFixed(1);
            setStatus(`Loading… ${pct}%`);
          } else {
            setStatus(`Loading… ${Math.round(xhr.loaded/1024)} kB`);
          }
        },
        (err) => {
          console.error('GLB load error:', err);
          setStatus('Failed to load model (check filename/path). Showing fallback.');
          fallbackMesh.visible = true;
          frameObject(fallbackMesh);
        }
      );

      function frameObject(obj, bbox) {
        const box = bbox || new THREE.Box3().setFromObject(obj);
        const size = new THREE.Vector3(); box.getSize(size);
        const center = new THREE.Vector3(); box.getCenter(center);

        controls.target.copy(center);

        const maxDim = Math.max(size.x, size.y, size.z) || 1.0;
        const fitHeight = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
        const fitWidth  = fitHeight / camera.aspect;
        const distance = 1.3 * Math.max(fitHeight, fitWidth);

        const dirVec = new THREE.Vector3(1, 0.5, 1).normalize();
        camera.position.copy(center).add(dirVec.multiplyScalar(distance));
        camera.near = Math.max(0.01, distance / 100);
        camera.far  = Math.max(2000, distance * 100);
        camera.updateProjectionMatrix();
      }

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Render loop
      renderer.setAnimationLoop(() => {
        controls.update();
        renderer.render(scene, camera);
      });
    </script>
  </body>
</html>
