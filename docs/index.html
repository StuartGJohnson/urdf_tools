<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Robot Viewer (Babylon.js)</title>
    <style>
      html,body{margin:0;height:100%;background:#0b0c10}
      #renderCanvas{width:100%;height:100%;display:block;touch-action:none}
      #status{
        position:fixed;left:8px;top:8px;padding:6px 10px;
        font:12px/1.2 system-ui,sans-serif;color:#cfd8dc;
        background:rgba(0,0,0,.4);border-radius:6px;z-index:10
      }
      #hint{
        position:fixed;left:8px;bottom:8px;padding:6px 10px;
        font:12px/1.2 system-ui,sans-serif;color:#cfd8dc;
        background:rgba(0,0,0,.4);border-radius:6px;opacity:.8
      }
    </style>
    <!-- Non-module globals (great for Pages) -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  </head>
  <body>
    <div id="status">Loading…</div>
    <div id="hint">Drag to orbit • Wheel/trackpad to zoom • Shift+drag to pan</div>
    <canvas id="renderCanvas"></canvas>

    <script>
      const MODEL_FILE = './ugv.glb'; // <<< change to './ugv.glb' etc.

      const setStatus = (s)=>document.getElementById('status').textContent=s;

      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});
      const scene  = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0.043, 0.047, 0.063, 1.0); // #0b0c10

      // Camera: ArcRotate = infinite azimuth by default
      const camera = new BABYLON.ArcRotateCamera("cam",
        -Math.PI/4,  // alpha (azimuth)
         Math.PI/3,  // beta  (elevation)
         3.0,        // radius
         BABYLON.Vector3.Zero(), scene);
      camera.lowerBetaLimit = 0.001;
      camera.upperBetaLimit = Math.PI - 0.001; // avoid the poles
      camera.wheelDeltaPercentage = 0.02;
      camera.panningSensibility = 800;
      camera.attachControl(canvas, true);

      // Lights
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
      hemi.intensity = 0.6;
      const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.5,-1,-0.6), scene);
      dir.position = new BABYLON.Vector3(5,10,7);
      dir.intensity = 1.0;

      // Ground grid helper
      const grid = BABYLON.MeshBuilder.CreateGround("grid", {width:10, height:10, subdivisions:20}, scene);
      const gridMat = new BABYLON.StandardMaterial("gridMat", scene);
      gridMat.diffuseColor = new BABYLON.Color3(0.12,0.14,0.18);
      gridMat.specularColor = new BABYLON.Color3(0,0,0);
      grid.material = gridMat; grid.position.y = -0.001;

      // Fallback box if loading fails
      const fallback = BABYLON.MeshBuilder.CreateBox("fallback", {width:1, height:0.3, depth:0.6}, scene);
      fallback.material = new BABYLON.StandardMaterial("fbMat", scene);
      fallback.material.diffuseColor = new BABYLON.Color3(0.30,0.78,0.31);
      fallback.setEnabled(false);

      function frameMeshes(meshes) {
        const min = new BABYLON.Vector3(+Infinity, +Infinity, +Infinity);
        const max = new BABYLON.Vector3(-Infinity, -Infinity, -Infinity);
        meshes.forEach(m => {
          if (!m.getBoundingInfo) return;
          const bi = m.getBoundingInfo();
          const vmin = bi.boundingBox.minimumWorld, vmax = bi.boundingBox.maximumWorld;
          min.minimizeInPlace(vmin); max.maximizeInPlace(vmax);
        });
        const center = min.add(max).scale(0.5);
        const size   = max.subtract(min);
        const maxDim = Math.max(size.x, size.y, size.z) || 1.0;

        camera.setTarget(center);
        camera.radius = maxDim * 1.3;
        camera.lowerRadiusLimit = maxDim * 0.2;
        camera.upperRadiusLimit = maxDim * 10.0;
        // If your GLB is Z-up, rotate once:
        // meshes[0].rotation.x = -Math.PI/2;
      }

      setStatus('Loading model…');
      BABYLON.SceneLoader.Append("", MODEL_FILE + "?v="+Date.now(), scene, () => {
        setStatus('Loaded.');
        const modelMeshes = scene.meshes.filter(m => m.name !== "grid" && m !== camera);
        if (modelMeshes.length === 0) {
          setStatus('Model loaded but no meshes found; showing fallback.');
          fallback.setEnabled(true); frameMeshes([fallback]);
        } else {
          frameMeshes(modelMeshes);
        }
      }, (evt) => {
        if (evt.lengthComputable) {
          setStatus(`Loading… ${(evt.loaded/evt.total*100).toFixed(1)}%`);
        } else {
          setStatus(`Loading… ${Math.round(evt.loaded/1024)} kB`);
        }
      }, (scene, message, exception) => {
        console.error("GLB load error:", message, exception);
        setStatus('Failed to load model (check filename/path). Showing fallback.');
        fallback.setEnabled(true); frameMeshes([fallback]);
      });

      window.addEventListener('resize', () => engine.resize());
      engine.runRenderLoop(() => scene.render());
    </script>
  </body>
</html>
