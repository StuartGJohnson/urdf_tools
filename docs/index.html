<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Robot Viewer (Three.js)</title>
    <style>
      html,body{margin:0;height:100%;background:#0b0c10}
      canvas{display:block}
      #msg{position:fixed;left:8px;bottom:8px;color:#cfd8dc;font:12px/1 sans-serif;opacity:.7}
    </style>
  </head>
  <body>
    <div id="msg">Drag to orbit • Mousewheel/trackpad to zoom • Shift+drag to pan</div>

    <!-- Everything via ES modules from CDN -->
    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.159.0/build/three.module.js';
      import { OrbitControls } from 'https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js';
      import { GLTFLoader } from 'https://unpkg.com/three@0.159.0/examples/jsm/loaders/GLTFLoader.js';

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0c10);

      const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 1000);
      camera.position.set(2, 1.5, 2);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;         // smooth motion
      controls.dampingFactor = 0.05;
      controls.enablePan = true;
      // Keep away from the exact poles to avoid any weirdness:
      controls.minPolarAngle = 0.0001;
      controls.maxPolarAngle = Math.PI - 0.0001;
      // No azimuth limits: spin as far as you like
      controls.minAzimuthAngle = -Infinity;
      controls.maxAzimuthAngle =  Infinity;

      // Soft lighting
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 10, 7);
      scene.add(dir);

      // Optional: ground grid to help orientation
      const grid = new THREE.GridHelper(10, 20, 0x334155, 0x1f2937);
      grid.position.y = -0.001;
      scene.add(grid);

      // Load the model from the same folder as this HTML
      const loader = new GLTFLoader();
      loader.load('./ugv.glb', (gltf) => {
        const root = gltf.scene;
        scene.add(root);

        // Frame the model
        const bbox = new THREE.Box3().setFromObject(root);
        const size = new THREE.Vector3(); bbox.getSize(size);
        const center = new THREE.Vector3(); bbox.getCenter(center);

        controls.target.copy(center);

        // Move camera back so the whole model fits
        const maxDim = Math.max(size.x, size.y, size.z);
        const fitHeightDistance = maxDim / (2 * Math.tan(THREE.MathUtils.degToRad(camera.fov) / 2));
        const fitWidthDistance  = fitHeightDistance / camera.aspect;
        const distance = 1.2 * Math.max(fitHeightDistance, fitWidthDistance);

        const dirVec = new THREE.Vector3(1, 0.5, 1).normalize(); // initial view direction
        camera.position.copy(center).add(dirVec.multiplyScalar(distance));
        camera.near = Math.max(0.01, distance / 100);
        camera.far  = distance * 100;
        camera.updateProjectionMatrix();

        // If your model's up-axis isn't Y, rotate here once:
        // root.rotation.x = -Math.PI / 2; // for Z-up -> Y-up conversion, for example
      }, (xhr) => {
        // progress (optional)
      }, (err) => {
        console.error('Failed to load ugv.glb', err);
        document.getElementById('msg').textContent = 'Failed to load ugv.glb (check path).';
      });

      // Resize handling
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Render loop
      renderer.setAnimationLoop(() => {
        controls.update();
        renderer.render(scene, camera);
      });
    </script>
  </body>
</html>
